import * as t from "io-ts";

interface IMinMaxArray<T> extends Array<T> {
  readonly minMaxArray: unique symbol;
}

const minMaxArray = <C extends t.Mixed>(min: number, max: number, a: C) =>
  t.brand(
    t.array(a),
    (n: Array<C>): n is t.Branded<Array<C>, IMinMaxArray<C>> =>
      min <= n.length && n.length <= max,
    "minMaxArray"
  );

/**
 * The row format generated by yarn outdated --json
 * 0: Package name
 * 1: Current Version
 * 2: Wanted Version
 * 3: Latest available version
 * 4: Package Type (devDependencies, dependencies, resolutionDependencies)
 * 5: Package URL
 */
const Row = minMaxArray(6, 6, t.string);

const Data = t.interface({
  body: t.readonlyArray(Row)
});

export const DependenciesTable = t.interface({
  type: t.string,
  data: Data
});

export type DependenciesTable = t.TypeOf<typeof DependenciesTable>;

const keyOfGroupBySeverity = ["major", "minor", "patch", "unknown"] as const;
type KeyOfGroupBySeverity = typeof keyOfGroupBySeverity[number];

export type GroupBySeverity = {
  [k in KeyOfGroupBySeverity]: number;
};

export const anyOutdated = (severity: GroupBySeverity) =>
  Object.keys(severity).some(x => severity[x as KeyOfGroupBySeverity] !== 0);

export const getSeverityType = (plain: string | null): KeyOfGroupBySeverity => {
  if (
    plain !== null &&
    keyOfGroupBySeverity.includes(plain as KeyOfGroupBySeverity)
  ) {
    return plain as KeyOfGroupBySeverity;
  } else {
    return "unknown";
  }
};

const keyOfGroupByType = [
  "devDependencies",
  "dependencies",
  "resolutionDependencies",
  "others"
] as const;
type KeyGroupByType = typeof keyOfGroupByType[number];

export type GroupByType = {
  [k in KeyGroupByType]: GroupBySeverity;
};

export type OutdatedPackage = {
  name: string;
  currentVersion: string;
  latestVersion: string;
  type: string;
  url: string;
};

export type OutdatedStats = {
  groupByType: GroupByType;
  mostOutdated: ReadonlyArray<OutdatedPackage>;
};

export const getTotalSeverity = (groupByType: GroupByType): GroupBySeverity =>
  Object.keys(groupByType).reduce(
    (acc, val) => ({
      major: groupByType[val as KeyGroupByType].major + acc.major,
      minor: groupByType[val as KeyGroupByType].minor + acc.minor,
      patch: groupByType[val as KeyGroupByType].patch + acc.patch,
      unknown: groupByType[val as KeyGroupByType].unknown + acc.unknown
    }),
    {
      major: 0,
      minor: 0,
      patch: 0,
      unknown: 0
    }
  );

export const getDependencyType = (plain: string): KeyGroupByType => {
  if (keyOfGroupByType.includes(plain as KeyGroupByType)) {
    return plain as KeyGroupByType;
  } else {
    return "others";
  }
};
