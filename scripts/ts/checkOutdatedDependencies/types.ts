import * as t from "io-ts";

interface IMinMaxArray<T> extends Array<T> {
  readonly minMaxArray: unique symbol;
}

const minMaxArray = <C extends t.Mixed>(min: number, max: number, a: C) =>
  t.brand(
    t.array(a),
    (n: Array<C>): n is t.Branded<Array<C>, IMinMaxArray<C>> =>
      min <= n.length && n.length <= max,
    "minMaxArray"
  );

/**
 * The row format generated by yarn outdated --json
 * 0: Package name
 * 1: Current Version
 * 2: Wanted Version
 * 3: Latest available version
 * 4: Package Type (devDependencies, dependencies, resolutionDependencies)
 * 5: Package URL
 */
const Row = minMaxArray(6, 6, t.string);

const Data = t.interface({
  body: t.readonlyArray(Row)
});

export const DependenciesTable = t.interface({
  type: t.string,
  data: Data
});

export type DependenciesTable = t.TypeOf<typeof DependenciesTable>;

const keyOfGroupBySeverity = ["major", "minor", "patch", "unknown"] as const;
type KeyOfGroupBySeverity = typeof keyOfGroupBySeverity[number];

export type GroupBySeverity = {
  [k in KeyOfGroupBySeverity]: number;
};

export const getSeverityType = (plain: string | null): KeyOfGroupBySeverity => {
  if (
    plain !== null &&
    keyOfGroupBySeverity.includes(plain as KeyOfGroupBySeverity)
  ) {
    return plain as KeyOfGroupBySeverity;
  } else {
    return "unknown";
  }
};

const keyOfGroupByType = [
  "devDependencies",
  "dependencies",
  "resolutionDependencies",
  "others"
] as const;
type KeyGroupByType = typeof keyOfGroupByType[number];

export type GroupByType = {
  [k in KeyGroupByType]: GroupBySeverity;
};

export const getDependencyType = (plain: string): KeyGroupByType => {
  if (keyOfGroupByType.includes(plain as KeyGroupByType)) {
    return plain as KeyGroupByType;
  } else {
    return "others";
  }
};
