import * as t from "io-ts";

import {
  ApiHeaderJson,
  AuthorizationBearerHeaderProducer,
  basicErrorResponseDecoder,
  basicResponseDecoder,
  BasicResponseType,
  composeHeaderProducers,
  composeResponseDecoders,
  createFetchRequestForApi,
  IGetApiRequestType,
  IPostApiRequestType,
  IPutApiRequestType,
  IResponseType,
  ResponseDecoder
} from "italia-ts-commons/lib/requests";
import { NonEmptyString } from "italia-ts-commons/lib/strings";

import { RptId, RptIdFromString } from "italia-ts-commons/lib/pagopa";
import { CodiceContestoPagamento } from "../../definitions/backend/CodiceContestoPagamento";
import { ExtendedProfile } from "../../definitions/backend/ExtendedProfile";
import { ImportoEuroCents } from "../../definitions/backend/ImportoEuroCents";
import { Installation } from "../../definitions/backend/Installation";
import { LimitedProfile } from "../../definitions/backend/LimitedProfile";
import { Messages } from "../../definitions/backend/Messages";
import { MessageWithContent } from "../../definitions/backend/MessageWithContent";
import { PaymentActivationsGetResponse } from "../../definitions/backend/PaymentActivationsGetResponse";
import { PaymentActivationsPostResponse } from "../../definitions/backend/PaymentActivationsPostResponse";
import { PaymentRequestsGetResponse } from "../../definitions/backend/PaymentRequestsGetResponse";
import { ProfileWithEmail } from "../../definitions/backend/ProfileWithEmail";
import { ProfileWithoutEmail } from "../../definitions/backend/ProfileWithoutEmail";
import { PublicSession } from "../../definitions/backend/PublicSession";
import { ServicePublic } from "../../definitions/backend/ServicePublic";
import { SessionToken } from "../types/SessionToken";
import { defaultRetryingFetch } from "../utils/fetch";

//
// Define composed types (e.g. oneOf) as they are not yet generated by
// gen-api-models
//

// ProfileWithOrWithoutEmail is oneOf [ProfileWithEmail, ProfileWithoutEmail]
const ProfileWithOrWithoutEmail = t.union([
  ProfileWithEmail,
  ProfileWithoutEmail
]);

export type ProfileWithOrWithoutEmail = t.TypeOf<
  typeof ProfileWithOrWithoutEmail
>;

// FullProfile is allOf [ExtendedProfile, LimitedProfile]
export const FullProfile = t.intersection([ExtendedProfile, LimitedProfile]);

export type FullProfile = t.TypeOf<typeof FullProfile>;

export const SuccessResponse = t.interface({
  message: t.string
});

export type SuccessResponse = t.TypeOf<typeof SuccessResponse>;

//
// Define the types of the requests
//

// A basic response type that also include 401
export type BasicResponseTypeWith401<R> =
  | BasicResponseType<R>
  | IResponseType<401, Error>;

// A basic response decoder that also include 401
export function basicResponseDecoderWith401<R, O = R>(
  type: t.Type<R, O>
): ResponseDecoder<BasicResponseTypeWith401<R>> {
  return composeResponseDecoders(
    basicResponseDecoder(type),
    basicErrorResponseDecoder(401)
  );
}

export type GetSessionT = IGetApiRequestType<
  {},
  "Authorization",
  never,
  BasicResponseTypeWith401<PublicSession>
>;

export type GetServiceT = IGetApiRequestType<
  {
    id: string;
  },
  "Authorization",
  never,
  BasicResponseType<ServicePublic>
>;

export type GetMessagesT = IGetApiRequestType<
  {
    cursor?: number;
  },
  "Authorization",
  "cursor",
  BasicResponseTypeWith401<Messages>
>;

export type GetMessageT = IGetApiRequestType<
  {
    id: string;
  },
  "Authorization",
  never,
  BasicResponseType<MessageWithContent>
>;

export type GetProfileT = IGetApiRequestType<
  {},
  "Authorization",
  never,
  BasicResponseTypeWith401<ProfileWithEmail | ProfileWithoutEmail>
>;

export type CreateOrUpdateProfileT = IPostApiRequestType<
  {
    newProfile: ExtendedProfile;
  },
  "Authorization" | "Content-Type",
  never,
  BasicResponseTypeWith401<LimitedProfile | ExtendedProfile>
>;

export type CreateOrUpdateInstallationT = IPutApiRequestType<
  {
    id: string;
    installation: Installation;
  },
  "Authorization" | "Content-Type",
  never,
  BasicResponseType<NonEmptyString>
>;

export type LogoutT = IPostApiRequestType<
  {},
  "Authorization" | "Content-Type",
  never,
  BasicResponseTypeWith401<SuccessResponse>
>;

export type VerificaRptT = IGetApiRequestType<
  {
    rptId: RptId;
  },
  "Authorization",
  never,
  BasicResponseTypeWith401<PaymentRequestsGetResponse>
>;

export type AttivaRptT = IPostApiRequestType<
  {
    rptId: string;
    paymentContextCode: CodiceContestoPagamento;
    amount: ImportoEuroCents;
  },
  "Authorization" | "Content-Type",
  never,
  BasicResponseTypeWith401<PaymentActivationsPostResponse>
>;

export type GetPaymentIdT = IGetApiRequestType<
  {
    paymentContextCode: CodiceContestoPagamento;
  },
  "Authorization",
  never,
  BasicResponseTypeWith401<PaymentActivationsGetResponse>
>;

export type BackendClientT = ReturnType<typeof BackendClient>;

//
// Create client
//

export function BackendClient(
  baseUrl: string,
  token: SessionToken,
  fetchApi: typeof fetch = defaultRetryingFetch()
) {
  const options = {
    baseUrl,
    fetchApi
  };

  const tokenHeaderProducer = AuthorizationBearerHeaderProducer(token);

  const getSessionT: GetSessionT = {
    method: "get",
    url: () => "/api/v1/session",
    query: _ => ({}),
    headers: composeHeaderProducers(tokenHeaderProducer, ApiHeaderJson),
    response_decoder: basicResponseDecoderWith401(PublicSession)
  };

  const getServiceT: GetServiceT = {
    method: "get",
    url: params => `/api/v1/services/${params.id}`,
    query: _ => ({}),
    headers: tokenHeaderProducer,
    response_decoder: basicResponseDecoder(ServicePublic)
  };

  const getMessagesT: GetMessagesT = {
    method: "get",
    url: () => `/api/v1/messages`,
    query: params => ({
      cursor: params.cursor ? `${params.cursor}` : ""
    }),
    headers: tokenHeaderProducer,
    response_decoder: basicResponseDecoderWith401(Messages)
  };

  const getMessageT: GetMessageT = {
    method: "get",
    url: params => `/api/v1/messages/${params.id}`,
    query: _ => ({}),
    headers: tokenHeaderProducer,
    response_decoder: basicResponseDecoder(MessageWithContent)
  };

  const getProfileT: GetProfileT = {
    method: "get",
    url: () => "/api/v1/profile",
    query: _ => ({}),
    headers: tokenHeaderProducer,
    response_decoder: basicResponseDecoderWith401(ProfileWithOrWithoutEmail)
  };

  const createOrUpdateProfileT: CreateOrUpdateProfileT = {
    method: "post",
    url: () => "/api/v1/profile",
    headers: composeHeaderProducers(tokenHeaderProducer, ApiHeaderJson),
    query: _ => ({}),
    body: p => JSON.stringify(p.newProfile),
    response_decoder: basicResponseDecoderWith401(ProfileWithOrWithoutEmail)
  };

  const createOrUpdateInstallationT: CreateOrUpdateInstallationT = {
    method: "put",
    url: params => `/api/v1/installations/${params.id}`,
    headers: composeHeaderProducers(tokenHeaderProducer, ApiHeaderJson),
    query: _ => ({}),
    body: p => JSON.stringify(p.installation),
    response_decoder: basicResponseDecoder(NonEmptyString)
  };

  const logoutT: LogoutT = {
    method: "post",
    url: () => "/logout",
    headers: composeHeaderProducers(tokenHeaderProducer, ApiHeaderJson),
    query: _ => ({}),
    body: _ => JSON.stringify({}),
    response_decoder: basicResponseDecoderWith401(SuccessResponse)
  };

  const verificaRptT: VerificaRptT = {
    method: "get",
    url: ({ rptId }) =>
      `/api/v1/payment-requests/${RptIdFromString.encode(rptId)}`,
    headers: tokenHeaderProducer,
    query: _ => ({}),
    response_decoder: basicResponseDecoderWith401(PaymentRequestsGetResponse)
  };

  const attivaRptT: AttivaRptT = {
    method: "post",
    url: () => "/api/v1/payment-activations",
    headers: composeHeaderProducers(tokenHeaderProducer, ApiHeaderJson),
    query: () => ({}),
    body: ({ rptId, paymentContextCode, amount }) =>
      JSON.stringify({
        rptId,
        codiceContestoPagamento: paymentContextCode,
        importoSingoloVersamento: amount
      }),
    response_decoder: basicResponseDecoderWith401(
      PaymentActivationsPostResponse
    )
  };

  const getPaymentIdT: GetPaymentIdT = {
    method: "get",
    url: ({ paymentContextCode }) =>
      `/api/v1/payment-activations/${paymentContextCode}`,
    headers: tokenHeaderProducer,
    query: () => ({}),
    response_decoder: basicResponseDecoderWith401(PaymentActivationsGetResponse)
  };

  return {
    getSession: createFetchRequestForApi(getSessionT, options),
    getService: createFetchRequestForApi(getServiceT, options),
    getMessages: createFetchRequestForApi(getMessagesT, options),
    getMessage: createFetchRequestForApi(getMessageT, options),
    getProfile: createFetchRequestForApi(getProfileT, options),
    createOrUpdateProfile: createFetchRequestForApi(
      createOrUpdateProfileT,
      options
    ),
    createOrUpdateInstallation: createFetchRequestForApi(
      createOrUpdateInstallationT,
      options
    ),
    logout: createFetchRequestForApi(logoutT, options),
    getVerificaRpt: createFetchRequestForApi(verificaRptT, options),
    postAttivaRpt: createFetchRequestForApi(attivaRptT, options),
    getPaymentId: createFetchRequestForApi(getPaymentIdT, options)
  };
}

// WIP: this is a mocked version of the BackendClient
// used to bypass the temporary non-working pagoPA proxy.
// any request to the verifica/attiva/getPaymentId functionalities
// will be replied to with the hardcoded information found here.
// In order to proceed with a valid payment (i.e. talk to the
// Payment Manager), a valid paymentId should be returned by
// getPaymentId
export const MockedBackendClient = (
  _: string,
  __: SessionToken,
  ___?: typeof fetch
): BackendClientT => {
  return {
    getSession: () =>
      Promise.resolve({
        headers: {},
        status: 200,
        value: {} as PublicSession
      } as BasicResponseType<PublicSession>),
    getService: () =>
      Promise.resolve({
        headers: {},
        status: 200,
        value: {} as ServicePublic
      } as BasicResponseType<ServicePublic>),
    getMessages: () =>
      Promise.resolve({
        headers: {},
        status: 200,
        value: {} as Messages
      } as BasicResponseType<Messages>),
    getMessage: () =>
      Promise.resolve({
        headers: {},
        status: 200,
        value: {} as MessageWithContent
      } as BasicResponseType<MessageWithContent>),
    getProfile: () =>
      Promise.resolve({
        headers: {},
        status: 200,
        value: {} as ProfileWithOrWithoutEmail
      } as BasicResponseType<ProfileWithOrWithoutEmail>),
    createOrUpdateProfile: () =>
      Promise.resolve({
        headers: {},
        status: 200,
        value: {} as ProfileWithOrWithoutEmail
      } as BasicResponseType<ProfileWithOrWithoutEmail>),
    createOrUpdateInstallation: () =>
      Promise.resolve({
        headers: {},
        status: 200,
        value: {} as NonEmptyString
      } as BasicResponseType<NonEmptyString>),
    logout: () =>
      Promise.resolve({
        headers: {},
        status: 200,
        value: {} as SuccessResponse
      } as BasicResponseType<SuccessResponse>),
    getVerificaRpt: () => {
      return Promise.resolve({
        headers: {},
        status: 200,
        value: {
          importoSingoloVersamento: 10052,
          codiceContestoPagamento: "de82ec409c7c11e8b39797ec146b9e06",
          ibanAccredito: "IT17X0605502100000001234567",
          causaleVersamento: "IMU 2018",
          enteBeneficiario: {
            identificativoUnivocoBeneficiario: "123",
            denominazioneBeneficiario: "Comune di Canicattì",
            codiceUnitOperBeneficiario: "01",
            denomUnitOperBeneficiario: "CDC",
            indirizzoBeneficiario: "Via Roma",
            civicoBeneficiario: "23",
            capBeneficiario: "92010",
            localitaBeneficiario: "Canicattì",
            provinciaBeneficiario: "Agrigento",
            nazioneBeneficiario: "IT"
          }
        } as PaymentRequestsGetResponse
      } as BasicResponseType<PaymentRequestsGetResponse>);
    },
    postAttivaRpt: () =>
      Promise.resolve({
        headers: {},
        status: 200,
        value: {
          rptId: "12345678901001135131330414611",
          importoSingoloVersamento: 10052 as ImportoEuroCents,
          codiceContestoPagamento: "de82ec409c7c11e8b39797ec146b9e06"
        } as PaymentActivationsPostResponse
      } as BasicResponseType<PaymentActivationsPostResponse>),
    getPaymentId: () =>
      Promise.resolve({
        headers: {},
        status: 200,
        value: {
          idPagamento: "556475ef-a1d1-4ba5-a6a3-42479a8646c9"
        } as PaymentActivationsGetResponse
      } as BasicResponseType<PaymentActivationsGetResponse>)
  };
};
